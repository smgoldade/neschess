#ifndef _NES_H_
#define _NES_H_

#include "../types.h"

/**
 * Turns off the PPU background and sprite rendering. Change takes effect after next NMI interrupt
 */
extern void __fastcall__ ppu_off(void);
/**
 * Turns on the PPU background and sprite rendering. Change takes effect after next NMI interrupt
 */
extern void __fastcall__ ppu_on(void);
/**
 * Adjusts the PPU's rendering settings. Change takes effect after next NMI interrupt
 * @param background 0 to turn off, 1 to turn on
 * @param sprite 0 to turn off, 1 to turn on
 */
extern void __fastcall__ ppu_rendering(u8 background, u8 sprite);
/**
 * Adjusts the PPU's show of the left most 8 pixels.
 * @param background 0 to hide, 1 to show
 * @param sprite 0 to hide, 1 to show
 */
extern void __fastcall__ ppu_show_left(u8 background, u8 sprite);
/**
 * Adjusts the PPU's emphasis settings
 * @param red 0 to turn off, 1 to turn on
 * @param green 0 to turn off, 1 to turn on
 * @param blue 0 to turn off, 1 to turn on
 */
extern void __fastcall__ ppu_emphasis(u8 red, u8 green, u8 blue);
/**
 * Adjusts the PPU's grayscale setting
 * @param enable 0 to turn off, 1 to turn on
 */
extern void __fastcall__ ppu_greyscale(u8 enable);
/**
 * Adjusts the PPU's scroll setting. Set at the next NMI.
 * @param x the x value to scroll to
 * @param y the y value to scroll to
 */
extern void __fastcall__ ppu_scroll(u8 x, u8 y);
/**
  * Adjusts the PPUs current rendered nametable. Set at the next NMI.
  * Also known as a "coarse scroll"
  * @param nametable
  */
extern void __fastcall__ ppu_nametable(u8 nametable);
/**
 * Adjusts the PPUs current pattern table for background and sprites. Set at the next NMI.
 * @param background 0 or 1 for the appropriate pattern table
 * @param sprite 0 or 1 for the appropriate pattern table
 */
extern void __fastcall__ ppu_pattern_table(u8 background, u8 sprite);
/**
 * Adjusts the PPUs current sprite size. Set at the next NMI.
 * @param large 0: 8x8, 1: 8x16
 */
extern void __fastcall__ ppu_sprite_size(u8 large);
/**
 * Adjusts the PPUs current master/slave setting. Set at the next NMI.
 * @param master 0: read backdrop from EXT, 1: output color on EXT
 */
extern void __fastcall__ ppu_master(u8 master);
/**
 * Adjusts the PPUs current NMI setting. Happens immediately.
 * @param enable 0: off, 1: on
 */
extern void __fastcall__ ppu_nmi(u8 enable);
/**
 * Waits until the next VBlank NMI finishes, then returns
 */
extern void __fastcall__ ppu_wait_nmi(void);
/**
 * Sets the PPU Address register to the provided address.
 * @param addr the address to set
 */
extern void __fastcall__ ppu_set_addr(u16 addr);
/**
 * Writes the given data to the PPU at the current address.
 * @param data the data to write
 * @param size the length of the data to write
 */
extern void __fastcall__ ppu_write(const u8* data, u16 size);

extern const volatile u8 ZP_PPU_FRAME_CNT;
#pragma zpsym ("ZP_PPU_FRAME_CNT");

/**
 * Nametable
 */

/**
 * Inserts data into the PPU update buffer to update the given nametable with the provided data.
 * This update happens during the vertical blanking NMI generated by the PPU.
 *
 * @param data the data to copy to the nametable
 * @param size the size of the data to copy
 * @param nametable the nametable to copy to (0-3)
 * @param x the x value on the nametable for the start of the data (0-31) (32 is like writing to the next line)
 * @param y the y value on the nametable for the start of the data (0-29) (30 & 31 will write attribute table!) (32 wraps back to 0)
 */
extern void __fastcall__ ppu_nmi_nt_update(const u8* data, u8 size, u8 nametable, u8 x, u8 y);

extern const u8* NAMETABLE_0;
extern const u8* NAMETABLE_1;
extern const u8* NAMETABLE_2;
extern const u8* NAMETABLE_3;

#define NT_WIDTH 32
#define NT_HEIGHT 30
#define NT0_ADDR(x,y) ((u16)(&NAMETABLE_0) | (y << 5) | x)
#define NT1_ADDR(x,y) ((u16)(&NAMETABLE_1) | (y << 5) | x)
#define NT2_ADDR(x,y) ((u16)(&NAMETABLE_2) | (y << 5) | x)
#define NT3_ADDR(x,y) ((u16)(&NAMETABLE_3) | (y << 5) | x)

extern const u8* ATTRIBUTE_TABLE_0;
extern const u8* ATTRIBUTE_TABLE_1;
extern const u8* ATTRIBUTE_TABLE_2;
extern const u8* ATTRIBUTE_TABLE_3;

#define AT_WIDTH 8
#define AT_HEIGHT 8
#define AT0_ADDR(x,y) ((u16)(&ATTRIBUTE_TABLE_0) | (y << 3) | x)
#define AT1_ADDR(x,y) ((u16)(&ATTRIBUTE_TABLE_1) | (y << 3) | x)
#define AT2_ADDR(x,y) ((u16)(&ATTRIBUTE_TABLE_2) | (y << 3) | x)
#define AT3_ADDR(x,y) ((u16)(&ATTRIBUTE_TABLE_3) | (y << 3) | x)
#define ATTRIBUTE_TOP_LEFT_READ(x) (x & 0x3)
#define ATTRIBUTE_TOP_RIGHT_READ(x) ((x & 0xC) >> 2)
#define ATTRIBUTE_BOTTOM_LEFT_READ(x) ((x & 0x30) >> 4)
#define ATTRIBUTE_BOTTOM_RIGHT_READ(x) ((x & 0xC0) >> 6)
#define ATTRIBUTE_TOP_LEFT_WRITE(x,y) x = (x & 0xFC) | (y & 0x3)
#define ATTRIBUTE_TOP_RIGHT_WRITE(x,y) x = (x & 0xF3) | ((y & 0x3) << 2)
#define ATTRIBUTE_BOTTOM_LEFT_WRITE(x,y) x = (x & 0xCF) | ((y & 0x3) << 4)
#define ATTRIBUTE_BOTTOM_RIGHT_WRITE(x,y) x = (x & 0x3F) | ((y & 0x3) << 6)

/**
 * Inserts data into the PPU update buffer to update the given attribute with the provided data.
 * This update happens during the vertical blanking NMI generated by the PPU.
 *
 * @param data the data to copy to the attribute table
 * @param size the size of the data to copy
 * @param attribute_table the attribute table to copy to (0-3)
 * @param x the x value on the attribute table for the start of the data
 * @param y the y value on the attribute table for the start of the data
 */
extern void __fastcall__ ppu_nmi_at_update(const u8* data, u8 size, u8 attribute_table, u8 x, u8 y);

/**
 * Palette
 */
typedef u8 nes_color;
typedef struct {
    nes_color background_color;
    nes_color color_1;
    nes_color color_2;
    nes_color color_3;
} nes_palette;

/**
 * Darkens a given color
 * @param color the color to darken
 * @return the darkened color
 */
extern nes_color __fastcall__ ppu_darken_color(nes_color color);

/**
 * Lightens a given color.
 * @param color the color to lighten
 * @return the lightened color.
 */
extern nes_color __fastcall__ ppu_lighten_color(nes_color color);

/**
 * Inserts data into the PPU update buffer to update the background palette.
 * This update happens during the vertical blanking NMI generated by the PPU.
 * @param data the background palette
 */
extern void __fastcall__ ppu_nmi_bg_pal_update(const nes_palette* data);

/**
 * Inserts data into the PPU update buffer to update the sprite palette.
 * This update happens during the vertical blanking NMI generated by the PPU.
 * @param data the sprite palette
 */
extern void __fastcall__ ppu_nmi_spr_pal_update(const nes_palette* data);

#define DARK_GRAY 0x00
#define DARK_AZURE 0x01
#define DARK_BLUE 0x02
#define DARK_VIOLET 0x03
#define DARK_MAGENTA 0x04
#define DARK_ROSE 0x05
#define DARK_RED 0x06
#define DARK_ORANGE 0x07
#define DARK_OLIVE 0x08
#define DARK_CHARTREUSE 0x09
#define DARK_GREEN 0x0A
#define DARK_SPRING 0x0B
#define DARK_CYAN 0x0C
#define ULTRA_BLACK 0x0D // should be avoided, causes "blacker than black"
#define MIRROR_BLACK 0x0E
#define BLACK 0x0F
#define MEDIUM_GRAY 0x10
#define MEDIUM_AZURE 0x11
#define MEDIUM_BLUE 0x12
#define MEDIUM_VIOLET 0x13
#define MEDIUM_MAGENTA 0x14
#define MEDIUM_ROSE 0x15
#define MEDIUM_RED 0x16
#define MEDIUM_ORANGE 0x17
#define MEDIUM_OLIVE 0x18
#define MEDIUM_CHARTREUSE 0x19
#define MEDIUM_GREEN 0x1A
#define MEDIUM_SPRING 0x1B
#define MEDIUM_CYAN 0x1C
#define WHITE 0x20
#define LIGHT_AZURE 0x21
#define LIGHT_BLUE 0x22
#define LIGHT_VIOLET 0x23
#define LIGHT_MAGENTA 0x24
#define LIGHT_ROSE 0x25
#define LIGHT_RED 0x26
#define LIGHT_ORANGE 0x27
#define LIGHT_OLIVE 0x28
#define LIGHT_CHARTREUSE 0x29
#define LIGHT_GREEN 0x2A
#define LIGHT_SPRING 0x2B
#define LIGHT_CYAN 0x2C
#define MIRROR_DARK_GRAY 0x2D
#define MIRROR_BLACK_2 0x2E
#define MIRROR_BLACK_3 0x2F
#define ULTRA_WHITE 0x30 // fades to black slower than standard white
#define PALE_AZURE 0x31
#define PALE_BLUE 0x32
#define PALE_VIOLET 0x33
#define PALE_MAGENTA 0x34
#define PALE_ROSE 0x35
#define PALE_RED 0x36
#define PALE_ORANGE 0x37
#define PALE_OLIVE 0x38
#define PALE_CHARTREUSE 0x39
#define PALE_GREEN 0x3A
#define PALE_SPRING 0x3B
#define PALE_CYAN 0x3C
#define MIRROR_MEDIUM_GRAY 0x3D
#define MIRROR_BLACK_4 0x3E
#define MIRROR_BLACK_5 0x3F

/**
 * Sprites
 */
typedef struct {
    u8 y;
    u8 tile_index;
    u8 attributes;
    u8 x;
} sprite;
extern sprite sprites[64];
#define SPRITE_PALETTE_WRITE(x,y) (x->attributes = (x->attributes & 0xE0) | (y & 0x3))
#define SPRITE_PRIORITY_WRITE(x,y) (x->attributes = (x->attributes & 0xC3) | ((y & 0x1) << 5))
#define SPRITE_HORIZONTAL_FLIP_WRITE(x,y) (x->attributes = (x->attributes & 0xA3) | ((y & 0x1) << 6))
#define SPRITE_VERTICAL_FLIP_WRITE(x,y) (x->attributes = (x->attributes & 0x63) | ((y & 0x1) << 7))

/**
 * Input
 */
#define BUTTON_RIGHT(x) (x & 0x1)
#define BUTTON_LEFT(x) (x & 0x2)
#define BUTTON_DOWN(x) (x & 0x4)
#define BUTTON_UP(x) (x & 0x8)
#define BUTTON_START(x) (x & 0x10)
#define BUTTON_SELECT(x) (x & 0x20)
#define BUTTON_B(x) (x & 0x40)
#define BUTTON_A(x) (x & 0x80)

/**
 * @return the currently held buttons on controller 1
 */
extern u8 __fastcall__ input_c1_held();
/**
 * @return the just pressed buttons on controller 1
 */
extern u8 __fastcall__  input_c1_pressed();
/**
 * @return the just released buttons on controller 1
 */
extern u8 __fastcall__ input_c1_released();
/**
 * @return the currently held buttons on controller 2
 */
extern u8 __fastcall__ input_c2_held();
/**
 * @return the just pressed buttons on controller 2
 */
extern u8 __fastcall__ input_c2_pressed();
/**
 * @return the just released buttons on controller 2
 */
extern u8 __fastcall__ input_c2_released();


#endif
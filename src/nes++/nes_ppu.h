// Author: Steven Goldade
#ifndef _NES_PPU_H_
#define _NES_PPU_H_
#include "core.h"
#include "nes_palette.h"

extern "C" void nmi();
extern "C" __attribute__((leaf)) void ppu_background_update();

namespace nespp {
    struct ppu_register {
        u8 control; /**<V - VBlank NMI (0: off, 1: on) <br/>
                    P - PPU Master Slave (0: read from EXT, 1: output on EXT) <br/>
                    H - Sprite Size (0: 8x8 sprite, 1: 8x16 sprite) <br/>
                    B - Background Pattern Table Address (0: $0000, 1: $1000) <br/>
                    S - Sprite Pattern Table Address (0: $0000, 1: $1000) <br/>
                    I - VRAM Increment per R/W of PPU_DATA (0: 1, 1: $20) <br/>
                    NN - Base Name Table Address (0: $2000, 1: $2400, 2: $2800, 3: $2C00 */
        u8 mask; /**< B - Emphasize blue <br/>
                  G - Emphasize green <br/>
                  R - Emphasize red <br/>
                  s - Show Sprites <br/>
                  b - Show Background <br/>
                  M - Show sprites in leftmost 8 pixels <br/>
                  m - Show background in leftmost 8 pixels <br/>
                  G - Grayscale*/
        const u8 status; /**< V - vblank has started <br/>
                          S - Sprite 0 Hit <br/>
                          O - Sprite overflow <br/>
                          ..... - Open Bus*/
        struct {
            u8 address;
            u8 data;
        } oam;
        u8 scroll;
        struct {
            u8 address;
            u8 data;
        } vram;
    };
    #define PPUREG (*(volatile struct ppu_register* const)0x2000)

    enum class Nametable {
        ZERO = 0,
        ONE = 1,
        TWO = 2,
        THREE = 3
    };

    class PPU {
    public :
        friend void ::nmi();

        auto set_rendering_state(bool background, bool sprite) -> void;
        auto set_left_mask(bool background, bool sprite) -> void;
        auto set_emphasis(bool red, bool green, bool blue) -> void;
        auto set_grayscale(bool enable) -> void;
        auto set_scroll(u8 x, u8 y) -> void;
        auto set_nametable(Nametable nametable) -> void;
        auto set_pattern_tables(bool background, bool sprite) -> void;
        auto set_sprite_size(bool large) -> void;
        auto set_master_mode(bool master) -> void;
        auto set_nmi_enable(bool enable) -> void;

        [[nodiscard]] auto is_rendering() const -> bool;
        [[nodiscard]] auto get_frame_counter() const -> u8;

        /**
         * Waits until the frame counter increases before returning.
         * The frame counter will increase during the NMI update.
         */
        auto wait() const -> void;

        /**
         * Background update that performs all the currently buffered actions
         * for the PPU, including data transfer and update to the control and mask registers.
         *
         * This will always be called during the vertical blank NMI, but can be manually called earlier to force
         * an immediate change.
         */
        auto background_update() -> void;

        auto nametable_update(const u8* data, u8 size, Nametable nametable, u8 x, u8 y) -> void;
        /**
         * Inserts data into the PPU update vram_buffer to update the given attribute with the provided data.
         * This update happens during the vertical blanking NMI generated by the PPU.
         *
         * @param data the data to copy to the attribute table
         * @param size the size of the data to copy
         * @param attribute_table the attribute table to copy to (0-3)
         * @param x the x value on the attribute table for the start of the data
         * @param y the y value on the attribute table for the start of the data
         */
        auto attribute_table_update(const u8* data, u8 size, Nametable nametable, u8 x, u8 y) -> void;

        auto background_palette_update(const nes_full_palette* palette) -> void;
        auto sprite_palette_update(const nes_full_palette* palette) -> void;

        // used for static initialization, just reference the ppu variable in the header to access the PPU.
        auto static get_instance() -> PPU&;
        PPU(PPU& other) = delete;
        auto operator=(const PPU& other) -> void = delete;
    private:
        PPU();

        auto nmi_update() -> void;

        volatile u8 frame_count;

        auto vram_buffer_insert(u16 address, const u8* data, u8 size) -> void;
        auto vram_palette_insert(u16 address, const nes_full_palette* palette) -> void;
    };

    // will be statically initialized by the library
    extern PPU* const ppu;
}
#endif //_NES_PPU_H_